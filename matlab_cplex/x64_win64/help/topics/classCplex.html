<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Function Reference: Cplex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_ilog.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<a href="#ibm-content"><img class="ibm-access" src="ftv2whitepixel.png" alt="Skip to main content"/></a>
<!-- Generated by Doxygen ..- -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Toolbox&nbsp;functions</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<a name="ibm-content">&nbsp;</a>
<div class="contents">
<h1>Cplex Class Reference</h1><!-- doxytag: class="Cplex" -->
<p>The <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class is the math programming solver.  
</p>

<p><a href="classCplex-members.html">List of all members.</a></p>
<table class="membersummary">
<tr><td colspan="2"><h2>Methods</h2></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a345ba28ba2674c2d753ec09141a30d1f">addCols</a> (obj, A, lb, ub, ctype, colname)</td></tr>
<tr><td class="mdescRight">A method of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that adds columns to the problem object.  <a href="#a345ba28ba2674c2d753ec09141a30d1f"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#aafab9804f095e094889b28ccdddf1e75">addIndicators</a> (variable, complemented, a, sense, rhs, varargin)</td></tr>
<tr><td class="mdescRight">Adds indicator constraints to the specified problem.  <a href="#aafab9804f095e094889b28ccdddf1e75"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a21779992067abbd5fceb8df298322e51">addQCs</a> (a, Q, sense, rhs, varargin)</td></tr>
<tr><td class="mdescRight">Adds a quadratic constraint or quadratic constraint set to a specified <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object.  <a href="#a21779992067abbd5fceb8df298322e51"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a5fdbb39fc4bd9a82ea2ce3a1a97801a3">addRows</a> (lhs, A, rhs, rowname)</td></tr>
<tr><td class="mdescRight">Adds constraints to a specified <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object.  <a href="#a5fdbb39fc4bd9a82ea2ce3a1a97801a3"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#aa03c4c2acf33463c57e3252092589277">addSOSs</a> (type, ind, wt, varargin)</td></tr>
<tr><td class="mdescRight">Adds information about a special ordered set (SOS) to a problem object of type MILP, MIQP, or MIQCP The problem maay already contain SOS information.  <a href="#aa03c4c2acf33463c57e3252092589277"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#af2071ffb67ca17fce28596156b85b3e2">Cplex</a> (modelname, varargin)</td></tr>
<tr><td class="mdescRight">The constructor for <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> objects.  <a href="#af2071ffb67ca17fce28596156b85b3e2"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a2faa599d4e42c89c19698b6a2eabdf60">delCols</a> (which)</td></tr>
<tr><td class="mdescRight">Removes columns with indices listed in <code>which</code> from the Model.  <a href="#a2faa599d4e42c89c19698b6a2eabdf60"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a81f99d901d07c55c6224fc8cf5b7340a">delRows</a> (which)</td></tr>
<tr><td class="mdescRight">Removes rows with indices listed in <code>which</code> from the Model.  <a href="#a81f99d901d07c55c6224fc8cf5b7340a"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a60764983f8eb778eda96c6220a9d2a9a">feasOpt</a> (preflhs, prefrhs, preflb, prefub)</td></tr>
<tr><td class="mdescRight">Computes a minimum-cost relaxation of the righthand side values of constraints or bounds on variables in order to make an infeasible problem feasible.  <a href="#a60764983f8eb778eda96c6220a9d2a9a"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#af270db28a71c9f4dffddcd5aa0e1b2e6">getChgParam</a> ()</td></tr>
<tr><td class="mdescRight">Returns a struct of parameters which are not set at their default values.  <a href="#af270db28a71c9f4dffddcd5aa0e1b2e6"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ae7e5b13b5dad38f13c4a40f7120e6f11">getProbType</a> ()</td></tr>
<tr><td class="mdescRight">Accesses the problem type.  <a href="#ae7e5b13b5dad38f13c4a40f7120e6f11"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ab8799d9bf890e0a09867a6d7bba27a9f">getVersion</a> ()</td></tr>
<tr><td class="mdescRight">Returns a string containing the version of CPLEX.  <a href="#ab8799d9bf890e0a09867a6d7bba27a9f"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a88709face4a361443141cf3d1d1729cf">populate</a> ()</td></tr>
<tr><td class="mdescRight">Generates multiple solutions to a mixed integer programming (MIP) problem.  <a href="#a88709face4a361443141cf3d1d1729cf"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ad086cbf92e3aa4ade94270067477f117">readBasis</a> (filename)</td></tr>
<tr><td class="mdescRight">Reads a basis from a BAS file and copies that basis into the <code>Start</code> property of the <code>Model</code>.  <a href="#ad086cbf92e3aa4ade94270067477f117"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ad31dee6ddcaba65cb876db53a7f5f120">readMipStart</a> (filename)</td></tr>
<tr><td class="mdescRight">Reads a MST file and copies the information of all the MIP starts contained in this file into a <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object.  <a href="#ad31dee6ddcaba65cb876db53a7f5f120"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#aee82fdc2fa98016a29e34781ff9f1a78">readModel</a> (filename)</td></tr>
<tr><td class="mdescRight">Reads a CPLEX model from a file and copies it into the invoking object.  <a href="#aee82fdc2fa98016a29e34781ff9f1a78"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ae30820da44dfd1e2ad8a1fc936ccd675">readOrder</a> (filename)</td></tr>
<tr><td class="mdescRight">Reads a priority order file from the file specified by filename.  <a href="#ae30820da44dfd1e2ad8a1fc936ccd675"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ad295203385eb6a86120d8be827b0a1b8">readParam</a> (filename)</td></tr>
<tr><td class="mdescRight">Reads parameters names and settings from the file specified by filename and copies them into the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> object.  <a href="#ad295203385eb6a86120d8be827b0a1b8"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a081a17ace1419d16524c38260447f049">refineConflict</a> ()</td></tr>
<tr><td class="mdescRight">Identifies a minimal conflict for the infeasibility of the linear constraints and the variable bounds in the current linear problem.  <a href="#a081a17ace1419d16524c38260447f049"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ae562fd5c8b4406706965d787ea8fb81c">refineMipStartConflict</a> (index)</td></tr>
<tr><td class="mdescRight">Refines a Conflict in order to determine why a given MIP start is not feasible in the linear problem.  <a href="#ae562fd5c8b4406706965d787ea8fb81c"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ab4a9813badf88d74de0c06acab634e14">setDefault</a> ()</td></tr>
<tr><td class="mdescRight">Resets all CPLEX parameters and settings to default values.  <a href="#ab4a9813badf88d74de0c06acab634e14"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#afd2f5388375d7bcf5257b72d59b69687">solve</a> ()</td></tr>
<tr><td class="mdescRight">Solves the current model in the invoking object.  <a href="#afd2f5388375d7bcf5257b72d59b69687"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a9673667bb52ed7b189146b1cdafc4ac7">terminate</a> ()</td></tr>
<tr><td class="mdescRight">Interrupts an ongoing <a class="el" href="classCplex.html#afd2f5388375d7bcf5257b72d59b69687" title="Solves the current model in the invoking object.">solve()</a> method invocation.  <a href="#a9673667bb52ed7b189146b1cdafc4ac7"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a14f2446347591c067dea9b4f68961508">tuneParam</a> (varargin)</td></tr>
<tr><td class="mdescRight">Tunes the parameters of the environment for improved optimizer performance on the specified problem object.  <a href="#a14f2446347591c067dea9b4f68961508"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a1864da014e0a765269c7aabc17bbef94">writeBasis</a> (filename)</td></tr>
<tr><td class="mdescRight">Writes the most current basis associated with a <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object to a file.  <a href="#a1864da014e0a765269c7aabc17bbef94"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a6b2430fc2b7cfc4e9346268c2b530434">writeConflict</a> (filename)</td></tr>
<tr><td class="mdescRight">Writes a Conflict file named filename.  <a href="#a6b2430fc2b7cfc4e9346268c2b530434"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a9a4d7f60d726bbadd9b730232061524f">writeMipStart</a> (filename)</td></tr>
<tr><td class="mdescRight">Writes a range of MIP starts of a <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object to a file in MST format.  <a href="#a9a4d7f60d726bbadd9b730232061524f"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a7dd8b7dd831720ee8e53a41fe1e00f42">writeModel</a> (filename)</td></tr>
<tr><td class="mdescRight">Writes the CPLEX model of the invoking object to a file.  <a href="#a7dd8b7dd831720ee8e53a41fe1e00f42"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ab46bca65f65d084b09f556f70cef91a3">writeOrder</a> (filename)</td></tr>
<tr><td class="mdescRight">Writes a priority order file into the file specified by filename.  <a href="#ab46bca65f65d084b09f556f70cef91a3"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a5d37e011bca6e7c2f05ca0405f144382">writeParam</a> (filename)</td></tr>
<tr><td class="mdescRight">Writes the parameter names and their current settings into the file specified by filename for all the CPLEX parameters that are not currently set at their default values.  <a href="#a5d37e011bca6e7c2f05ca0405f144382"></a></td></tr>
<tr><td colspan="2"><h2>Properties</h2></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ae89be875a50e01094ab91b97f89b3877">Conflict</a></td></tr>
<tr><td class="mdescRight">A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the conflict of the model.  <a href="#ae89be875a50e01094ab91b97f89b3877"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ad15aa55e15ab198965472a5517db380b">DisplayFunc</a></td></tr>
<tr><td class="mdescRight">A property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that is a pointer to a function which provides control of display of output.  <a href="#ad15aa55e15ab198965472a5517db380b"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#adde752cbaa0027277c16f0a69c02d893">InfoCallback</a></td></tr>
<tr><td class="mdescRight">A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that is a pointer to an informational callback.  <a href="#adde752cbaa0027277c16f0a69c02d893"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#ae5bccc8c64cd3b710aa367c386de6650">MipStart</a></td></tr>
<tr><td class="mdescRight">A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the MipStart of the MIP model.  <a href="#ae5bccc8c64cd3b710aa367c386de6650"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a051e4d035e053a4636efc58c1bde9b3e">Model</a></td></tr>
<tr><td class="mdescRight">A property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the model used by the math programming solver.  <a href="#a051e4d035e053a4636efc58c1bde9b3e"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#afbb7a18945a0832b5189bbe768dd0c51">Order</a></td></tr>
<tr><td class="mdescRight">A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the priority order.  <a href="#afbb7a18945a0832b5189bbe768dd0c51"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a56d92885c62355169101500c45638e29">Param</a></td></tr>
<tr><td class="mdescRight">A property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the parameters for the math programming solver.  <a href="#a56d92885c62355169101500c45638e29"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#a93e3891009533aaefce016703acb30d4">Solution</a></td></tr>
<tr><td class="mdescRight">A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the solution of the model.  <a href="#a93e3891009533aaefce016703acb30d4"></a></td></tr>
<tr><td class="memItemRight" valign="bottom"><a class="el" href="classCplex.html#aedcef5fb0e94ecd6e477e87d7bb5b13a">Start</a></td></tr>
<tr><td class="mdescRight">A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the Start of the LP or QP model.  <a href="#aedcef5fb0e94ecd6e477e87d7bb5b13a"></a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class is the math programming solver. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">   out = <a class="code" href="classCplex.html#af2071ffb67ca17fce28596156b85b3e2" title="The constructor for Cplex objects.">Cplex</a>(modelname); 
   out = <a class="code" href="classCplex.html#af2071ffb67ca17fce28596156b85b3e2" title="The constructor for Cplex objects.">Cplex</a>(prob); 
</pre></div> <code>modelname</code> is an optional argument to specify the problem name <br/>
 <code>prob</code> is an optional argument to specify the problem structure</dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>The <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class of IBM&reg; ILOG&reg; CPLEX&reg; for MATLAB&reg; stores the model and provides methods for the solution, analysis, manipulation and reading/writing of the model file. All of the data associated with the problem is stored in the properties of a <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> object. These class properties are standard MATLAB data structures and can be manipulated directly within MATLAB. However, modifying the problem using methods provided in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class enforces consistency, such as ensuring that vectors are of the proper length.</dd></dl>
<p>The constructor <code><a class="el" href="classCplex.html#af2071ffb67ca17fce28596156b85b3e2" title="The constructor for Cplex objects.">Cplex()</a></code> creates a <code><a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a></code> object that only has the properties <code>cplex.Model</code>, <code>cplex.Param</code> and <code>cplex.DisplayFunc</code>. The other properties are optional. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a name="Cplex"></a><a class="anchor" id="af2071ffb67ca17fce28596156b85b3e2"></a><!-- doxytag: member="Cplex::Cplex" ref="af2071ffb67ca17fce28596156b85b3e2" args="(modelname, varargin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cplex </td>
          <td>(</td>
          <td class="paramtype">modelname</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">varargin</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The constructor for <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> objects. </p>
<p>The constructor takes one optional argument to specify the problem name or a problem structure of one of the forms described in each toolbox function. Note that if the problem structure contains information for a least squares problem (<code>C</code> and <code>d</code>) it may not contain a quadratic or linear objective (<code>H</code> and <code>f</code>).</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex=<a class="code" href="classCplex.html#af2071ffb67ca17fce28596156b85b3e2" title="The constructor for Cplex objects.">Cplex</a>(name)
 cplex=<a class="code" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a>(prob)
</pre></div></dd></dl>
<dl class="user"><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex=<a class="code" href="classCplex.html#af2071ffb67ca17fce28596156b85b3e2" title="The constructor for Cplex objects.">Cplex</a>(<span class="stringliteral">&#39;prob&#39;</span>)
</pre></div> or <div class="fragment"><pre class="fragment"> prob.f = 1
 prob.Aineq = 1;
 prob.bineq = 10;
 prob.ub    = 5;
 cplex = <a class="code" href="classCplex.html#af2071ffb67ca17fce28596156b85b3e2" title="The constructor for Cplex objects.">Cplex</a>(prob);
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>name</em>&nbsp;</td><td>String - problem name </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>prob</em>&nbsp;</td><td>struct - problem structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Method detail</h2>
<a name="addCols"></a><a class="anchor" id="a345ba28ba2674c2d753ec09141a30d1f"></a><!-- doxytag: member="Cplex::addCols" ref="a345ba28ba2674c2d753ec09141a30d1f" args="(cpx, obj, A, lb, ub, ctype, colname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">addCols </td>
          <td>(</td>
          <td class="paramtype">obj</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">A</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">lb</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">ub</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">ctype</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">colname</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A method of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that adds columns to the problem object. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">         cplex.addCols(obj)
         cplex.addCols(obj,A)
         cplex.addCols(obj,A,lb)
         cplex.addCols(obj,A,lb,ub)
         cplex.addCols(obj,A,lb,ub,ctype)
         cplex.addCols(obj,A,lb,ub,ctype,name)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Add a single column without ctype and colname: <div class="fragment"><pre class="fragment">         cplex.addCols(1, 2, 1, 10);
</pre></div> Add a single column with ctype and colname: <div class="fragment"><pre class="fragment">         cplex.addCols(1, 2, 1, 10, <span class="charliteral">&#39;I&#39;</span>, <span class="stringliteral">&#39;colname&#39;</span>);
</pre></div> Add multiple columns without ctype and colname: <div class="fragment"><pre class="fragment">         cplex.addCols([1 1 1]<span class="stringliteral">&#39;, </span>
<span class="stringliteral">                      [1 2 3;4 5 6;7 8 9], </span>
<span class="stringliteral">                       [1 1 1]&#39;</span>, 
                     [10 10 10]<span class="stringliteral">&#39;);   </span>
</pre></div> Add multiple columns with ctype and colname: <div class="fragment"><pre class="fragment">         cplex.addCols([1 1 1]<span class="stringliteral">&#39;, </span>
<span class="stringliteral">                      [1 2 3;4 5 6;7 8 9], </span>
<span class="stringliteral">                     [1 1 1]&#39;</span>, [10 10 10]<span class="stringliteral">&#39;, </span>
<span class="stringliteral">                     &#39;</span>IBI<span class="stringliteral">&#39;, [&#39;</span>c1<span class="charliteral">&#39;;&#39;</span>c2<span class="charliteral">&#39;;&#39;</span>c3<span class="stringliteral">&#39;]); </span>
</pre></div> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>obj</em>&nbsp;</td><td>Double column vector - Objective function coefficients of the new variables. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>A</em>&nbsp;</td><td>Double matrix - Constraint matrix to be added to the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object by columns. Optional. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>lb</em>&nbsp;</td><td>Double column vector - Lower bound on each of the new variables. Optional. If <code>lb</code> is not provided, <code>lb</code> defaults to <code>zeros(length(obj),1)</code>. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>ub</em>&nbsp;</td><td>Double column vector - Upper bound on each of the new variables. Optional. If <code>ub</code> is not provided, <code>ub</code> defaults to <code>ones(length(obj),1)*Inf</code>. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>ctype</em>&nbsp;</td><td>String - Type of each column in the constraint matrix, specify whether a variable is continuous, integer, binary, semi-continuous, or semi-integer. Optional.If <code>ctype</code> is not provided, <code>ctype</code> defaults to <code>char(ones([1 length(obj)])*('C'))</code>. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>colname</em>&nbsp;</td><td>Char matrix - Names of the new columns. Optional.</td></tr>
  </table>
  </dd>
</dl>
<p>See also the example lpex1.m. </p>

</div>
</div>
<a name="addIndicators"></a><a class="anchor" id="aafab9804f095e094889b28ccdddf1e75"></a><!-- doxytag: member="Cplex::addIndicators" ref="aafab9804f095e094889b28ccdddf1e75" args="(cpx, variable, complemented, a, sense, rhs, varargin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">addIndicators </td>
          <td>(</td>
          <td class="paramtype">variable</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">complemented</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">a</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">sense</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">rhs</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">varargin</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds indicator constraints to the specified problem. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">         cplex.addIndicators(variable,complemented, a,sense,rhs)
         cplex.addIndicators(variable,complemented, a,sense,rhs, name)
         cplex.addIndicators(indicator)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Add one indicator with a name <div class="fragment"><pre class="fragment"> cplex.addIndicators(5, 1, [1 2 3 4 5 6]<span class="stringliteral">&#39;, &#39;</span>E<span class="stringliteral">&#39;, 100, {&#39;</span>indc3<span class="stringliteral">&#39;});</span>
</pre></div> Add two indicators with names <div class="fragment"><pre class="fragment"> cplex.addIndicators ([5 6], [0 0], {[1 1 2 2]<span class="stringliteral">&#39; [1 2 3 4 5]&#39;</span>},
                      <span class="stringliteral">&#39;EE&#39;</span>, [10 100], {<span class="stringliteral">&#39;indc3&#39;</span> <span class="stringliteral">&#39;indc4&#39;</span>});
</pre></div> Add indicator structure or structure vector <div class="fragment"><pre class="fragment"> cplex.addIndicators(indicator);
</pre></div> where <code>indicator</code> is structure or structure vector which has the fields <code>variable</code>, <code>complemented</code>, <code>a</code>, <code>sense</code>, <code>rhs</code> and an optional <code>name</code>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>variable</em>&nbsp;</td><td>Double or vector - Binary variable that acts as the indicator for this constraint. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>complemented</em>&nbsp;</td><td>Double or vector - Boolean value that specifies whether the indicator variable is complemented. The linear constraint must be satisfied when the indicator takes a value of 1 (one) if the indicator is not complemented, and similarly, the linear constraint must be satisfied when the indicator takes a value of 0 (zero) if the indicator is complemented. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>a</em>&nbsp;</td><td>Double column vector or cell vector - Linear portion of the indicator constraint. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>sense</em>&nbsp;</td><td>Char 'L','G' or 'E' or string - Sense of the linear portion of the constraint. Specify 'L' for &lt;= or 'G' for &gt;= or 'E' for ==. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>rhs</em>&nbsp;</td><td>Double or double row vector - Righthand side value for the linear portion of the indicator constraint. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>name</em>&nbsp;</td><td>Optional parameter cell vector - Name of the constraint to be added. May be empty, in which case the new constraint is assigned a default name if the indicator constraints already present in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object have names; otherwise, no name is associated with the constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="addQCs"></a><a class="anchor" id="a21779992067abbd5fceb8df298322e51"></a><!-- doxytag: member="Cplex::addQCs" ref="a21779992067abbd5fceb8df298322e51" args="(cpx, a, Q, sense, rhs, varargin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">addQCs </td>
          <td>(</td>
          <td class="paramtype">a</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">Q</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">sense</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">rhs</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">varargin</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a quadratic constraint or quadratic constraint set to a specified <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">          cplex.addQCs(a, Q, sense, rhs)
          cplex.addQCs(a, Q, sense, rhs, name)
          cplex.addQCs(qc)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Add single quadratic constraint <div class="fragment"><pre class="fragment">          cplex.addQCs([0 0 0]<span class="stringliteral">&#39;,[1 0 0;0 1 0;0 0 1],&#39;</span>L<span class="stringliteral">&#39;,1,{&#39;</span>qc1<span class="stringliteral">&#39;});</span>
</pre></div> Add quadtratic constraint set <div class="fragment"><pre class="fragment">          cplex.addQCs(
                 [0 0 0;1 0 0;0 1 0]<span class="stringliteral">&#39;,</span>
<span class="stringliteral">                 {[1 0 0;0 1 0;0 0 1]</span>
<span class="stringliteral">                  [1 0 0;0 1 0;0 0 1]</span>
<span class="stringliteral">                  [1 0 0;0 1 0;0 0 1]},</span>
<span class="stringliteral">                 &#39;</span>LLG<span class="stringliteral">&#39;,</span>
<span class="stringliteral">                 [1.0 2.0 3.0],</span>
<span class="stringliteral">                 {&#39;</span>qc1<span class="charliteral">&#39; &#39;</span>qc2<span class="charliteral">&#39; &#39;</span>qc3<span class="stringliteral">&#39;});</span>
</pre></div> Add quadratic structure or structure vector <div class="fragment"><pre class="fragment">          cplex.addQCs(qc);
</pre></div> where <code>qc</code> is structure or structure vector with <code>a</code>, <code>Q</code>, <code>sense</code>, <code>rhs</code>, and optional <code>name</code> fields.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>a</em>&nbsp;</td><td>Double column vector or matrix - Linear part of the quadratic constraint to be added by column. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>Q</em>&nbsp;</td><td>Double matrix or cell vector Quadratic part of the quadratic constraint to be added. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>sense</em>&nbsp;</td><td>Char 'L' or 'G' or string - Sense of the constraint to be added. Note that quadratic constraints may only be less-than-or-equal-to or greater-than-or-equal-to constraints. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>rhs</em>&nbsp;</td><td>Double or double row vector - Righthand side term for the constraint to be added. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>name</em>&nbsp;</td><td>Cell vector - The name of the constraint to be added. Optional.</td></tr>
  </table>
  </dd>
</dl>
<p>See also the example qcpex1.m. </p>

</div>
</div>
<a name="addRows"></a><a class="anchor" id="a5fdbb39fc4bd9a82ea2ce3a1a97801a3"></a><!-- doxytag: member="Cplex::addRows" ref="a5fdbb39fc4bd9a82ea2ce3a1a97801a3" args="(cpx, lhs, A, rhs, rowname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">addRows </td>
          <td>(</td>
          <td class="paramtype">lhs</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">A</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">rhs</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">rowname</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds constraints to a specified <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.addRows(lhs,A,rhs)
 cplex.addRows(lhs,A,rhs,name)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Add a single row without rowname <div class="fragment"><pre class="fragment"> cplex.addRows(1,[1 2 3],10); 
</pre></div> Add a single row with rowname <div class="fragment"><pre class="fragment"> cplex.addRows(1,[1 2 3],10,<span class="stringliteral">&#39;rowname&#39;</span>)
</pre></div> Add multiple rows without rowname <div class="fragment"><pre class="fragment"> cplex.addRows([1 1 1]<span class="stringliteral">&#39;,</span>
<span class="stringliteral">               [1 2 3;</span>
<span class="stringliteral">                4 5 6;</span>
<span class="stringliteral">                7 8 9],</span>
<span class="stringliteral">               [10 20 30]&#39;</span>); 
</pre></div> Add multiple rows with rowname <div class="fragment"><pre class="fragment"> cplex.addRows([1 1 1]<span class="stringliteral">&#39;,</span>
<span class="stringliteral">               [1 2 3;</span>
<span class="stringliteral">                4 5 6;</span>
<span class="stringliteral">                7 8 9],</span>
<span class="stringliteral">               [10 20 30]&#39;</span>,
               [<span class="stringliteral">&#39;r1&#39;</span>;<span class="stringliteral">&#39;r2&#39;</span>;<span class="stringliteral">&#39;r3&#39;</span>]);
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>lhs</em>&nbsp;</td><td>Double column vector - Lefthand side term for each constraint to be added to the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>A</em>&nbsp;</td><td>Double matrix - The constraint matrix to be added to the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object by rows. Optional. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>rhs</em>&nbsp;</td><td>Double column vector - Righthand side term for each constraint to be added to the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>rowname</em>&nbsp;</td><td>Char matrix - Names of the new rows. Optional.</td></tr>
  </table>
  </dd>
</dl>
<p>See also the example lpex1.m. </p>

</div>
</div>
<a name="addSOSs"></a><a class="anchor" id="aa03c4c2acf33463c57e3252092589277"></a><!-- doxytag: member="Cplex::addSOSs" ref="aa03c4c2acf33463c57e3252092589277" args="(cpx, type, ind, wt, varargin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">addSOSs </td>
          <td>(</td>
          <td class="paramtype">type</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">ind</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">wt</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">varargin</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds information about a special ordered set (SOS) to a problem object of type MILP, MIQP, or MIQCP The problem maay already contain SOS information. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.addSOSs(type, ind, wt)
 cplex.addSOSs(type, ind, wt, name)
 cplex.addSOSs(sos)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Add a single SOS: <div class="fragment"><pre class="fragment"> cplex.addSOSs(<span class="charliteral">&#39;1&#39;</span>, [1 2 3]<span class="stringliteral">&#39;, [1 2 3]&#39;</span>, {<span class="stringliteral">&#39;sos1(1)&#39;</span>}); 
</pre></div> Add a set of 2 SOSs: <div class="fragment"><pre class="fragment"> cplex.addSOSs(<span class="stringliteral">&#39;12&#39;</span>, 
               {[1 2 3]<span class="stringliteral">&#39; [4 5 6]&#39;</span>}, 
               {[2 3 4]<span class="stringliteral">&#39; [5 6 7]&#39;</span>}, 
               {<span class="stringliteral">&#39;s1&#39;</span> <span class="stringliteral">&#39;s2&#39;</span>});
</pre></div> Add SOS structure or structure vector: <div class="fragment"><pre class="fragment"> cplex.addSOSs(sos);
</pre></div> where <code>sos</code> is a structure or structure vector with fields <code>type</code>, <code>ind</code>, <code>wt</code> and an optional <code>name</code>.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>type</em>&nbsp;</td><td>Char '1' or '2' or string - SOS type information for the sets to be added. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>ind</em>&nbsp;</td><td>Double column vector or cell vector - Indices for the sets to be added. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>wt</em>&nbsp;</td><td>Double column vector or cell vector - Weights for the sets to be added. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>name</em>&nbsp;</td><td>Cell vector - Names of the new SOSs. Optional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="delCols"></a><a class="anchor" id="a2faa599d4e42c89c19698b6a2eabdf60"></a><!-- doxytag: member="Cplex::delCols" ref="a2faa599d4e42c89c19698b6a2eabdf60" args="(cpx, which)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delCols </td>
          <td>(</td>
          <td class="paramtype">which</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes columns with indices listed in <code>which</code> from the Model. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.delCols(which)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Delete the variables in positions 1, 2 and 5 <div class="fragment"><pre class="fragment"> cplex.delCols ([1 2 5])
</pre></div> Delete the first 100 variables <div class="fragment"><pre class="fragment"> cplex.delCols ([1:100])
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>which</em>&nbsp;</td><td>Double vector - Indices of the variables (columns) to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="delRows"></a><a class="anchor" id="a81f99d901d07c55c6224fc8cf5b7340a"></a><!-- doxytag: member="Cplex::delRows" ref="a81f99d901d07c55c6224fc8cf5b7340a" args="(cpx, which)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delRows </td>
          <td>(</td>
          <td class="paramtype">which</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes rows with indices listed in <code>which</code> from the Model. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.delRows(which)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Delete the constraints in positions 1, 2 and 5 <div class="fragment"><pre class="fragment"> cplex.delCols ([1 2 5])
</pre></div> Delete the first 100 constraints <div class="fragment"><pre class="fragment"> cplex.delCols ([1:100])
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>which</em>&nbsp;</td><td>Double vector - Indices of the constraints (rows) to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="feasOpt"></a><a class="anchor" id="a60764983f8eb778eda96c6220a9d2a9a"></a><!-- doxytag: member="Cplex::feasOpt" ref="a60764983f8eb778eda96c6220a9d2a9a" args="(cpx, preflhs, prefrhs, preflb, prefub)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">feasOpt </td>
          <td>(</td>
          <td class="paramtype">preflhs</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">prefrhs</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">preflb</td>
          <td class="paramname">, </td>
          <td class="paramkey"></td>
          <td class="paramtype">prefub</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a minimum-cost relaxation of the righthand side values of constraints or bounds on variables in order to make an infeasible problem feasible. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.feasOpt(preflhs, prefrhs, preflb, prefub)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>If one parameter is empty, set it to <code>[]</code>. <div class="fragment"><pre class="fragment"> prefrhs=[];
 cplex.feasOpt(preflhs, prefrhs, preflb, prefub)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>preflhs</em>&nbsp;</td><td>Double column vector - The length must be at least equal to the number of rows in the problem. An empty vector may be specified if no range values are allowed to be relaxed or none are present in the active problem. When not empty, the vector specifies the preference values that determine the cost of relaxing each range. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>prefrhs</em>&nbsp;</td><td>Double column vector - The length must be at least equal to the number of rows in the problem. An empty vector may be specified if no rhs values are are allowed to be relaxed. When not empty, the vector specifies the preference values that determine the cost of relaxing each constraint. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>preflb</em>&nbsp;</td><td>Double column vector - The length must be at least equal to the number of columns in the problem. An empty vector may be passed if no lower bound of any variable is allowed to be relaxed. When not empty, the vector specifies the preference values that determine the cost of relaxing each lower bound. </td></tr>
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>prefub</em>&nbsp;</td><td>Double column vector - The length must be at least equal to the number of columns in the problem. An empty vector may be passed if no upper bound of any variable is allowed to be relaxed. When not empty, the vector specifies the preference values that determine the cost of relaxing each upper bound.</td></tr>
  </table>
  </dd>
</dl>
<table  class="usertable">
<tr>
<th>Parameter FeasOptMode </th><th>Value </th><th>Meaning  </th></tr>
<tr>
<td>CPX_FEASOPT_MIN_SUM </td><td>0 </td><td>Minimize the sum of all required relaxations in first phase only; default.  </td></tr>
<tr>
<td>CPX_FEASOPT_OPT_SUM </td><td>1 </td><td>Minimize the sum of all required relaxations in first phase and execute second phase to find optimum among minimal relaxations.  </td></tr>
<tr>
<td>CPX_FEASOPT_MIN_INF </td><td>2 </td><td>Minimize the number of constraints and  </td></tr>
<tr>
<td>CPX_FEASOPT_OPT_INF </td><td>3 </td><td>Minimize the number of constraints and bounds requiring relaxation in first phase and execute second phase to find optimum among minimal relaxations.  </td></tr>
<tr>
<td>CPX_FEASOPT_MIN_QUAD </td><td>4 </td><td>Minimize the sum of squares of  </td></tr>
<tr>
<td>CPX_FEASOPT_OPT_QUAD </td><td>5 </td><td>Minimize the sum of squares of required relaxations in first phase and execute second phase to find optimum among minimal relaxations.  </td></tr>
</table>
<dl class="user"><dt><b>Note:</b></dt><dd>This function can minimize the weighted sum of the penalties for relaxations (denoted by SUM). It can minimize the weighted number of relaxed bounds and constraints (denoted by INF). It can minimize the weighted sum of the squared penalties of the relaxations (denoted by QUAD). </dd></dl>

</div>
</div>
<a name="getChgParam"></a><a class="anchor" id="af270db28a71c9f4dffddcd5aa0e1b2e6"></a><!-- doxytag: member="Cplex::getChgParam" ref="af270db28a71c9f4dffddcd5aa0e1b2e6" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">getChgParam </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a struct of parameters which are not set at their default values. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.getChgParam()
</pre></div> </dd></dl>

</div>
</div>
<a name="getProbType"></a><a class="anchor" id="ae7e5b13b5dad38f13c4a40f7120e6f11"></a><!-- doxytag: member="Cplex::getProbType" ref="ae7e5b13b5dad38f13c4a40f7120e6f11" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">getProbType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accesses the problem type. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.getProbType()
</pre></div></dd></dl>
<dl class="user"><dt><b>Return Values:</b></dt><dd><table class="doxtable">
<tr>
<th>Return value </th><th>Problem type  </th></tr>
<tr>
<td>-1 </td><td>Error: no problem or environment. </td></tr>
<tr>
<td>0 </td><td>Linear program; no quadratic data or ctype information stored. </td></tr>
<tr>
<td>1 </td><td>Problem with ctype information. </td></tr>
<tr>
<td>3 </td><td>Problem with ctype information, integer variables fixed. </td></tr>
<tr>
<td>5 </td><td>Problem with quadratic data stored. </td></tr>
<tr>
<td>7 </td><td>Problem with quadratic data and ctype information. </td></tr>
<tr>
<td>8 </td><td>Problem with quadratic data and ctype information, integer variables fixed. </td></tr>
<tr>
<td>10 </td><td>Problem with quadratic constraints. </td></tr>
<tr>
<td>11 </td><td>Problem with quadratic constraints and ctype information.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a name="getVersion"></a><a class="anchor" id="ab8799d9bf890e0a09867a6d7bba27a9f"></a><!-- doxytag: member="Cplex::getVersion" ref="ab8799d9bf890e0a09867a6d7bba27a9f" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">getVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a string containing the version of CPLEX. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.getVersion()
</pre></div> </dd></dl>

</div>
</div>
<a name="populate"></a><a class="anchor" id="a88709face4a361443141cf3d1d1729cf"></a><!-- doxytag: member="Cplex::populate" ref="a88709face4a361443141cf3d1d1729cf" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">populate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates multiple solutions to a mixed integer programming (MIP) problem. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.populate()
</pre></div></dd></dl>
<dl class="user"><dt><b>Description</b></dt><dd>After a call to solve, the field <code>Solution</code> of the invoking object will be populated as well as the field <code>Start</code> for an LP or <code>MipStart</code> for a MIP.</dd></dl>
<p>See also the example lpex1.m. </p>

</div>
</div>
<a name="readBasis"></a><a class="anchor" id="ad086cbf92e3aa4ade94270067477f117"></a><!-- doxytag: member="Cplex::readBasis" ref="ad086cbf92e3aa4ade94270067477f117" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readBasis </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a basis from a BAS file and copies that basis into the <code>Start</code> property of the <code>Model</code>. </p>
<p>The parameter <code>advance</code> must be set to 1 (one), its default value, or 2 (two) in order for the basis to be used for starting a subsequent optimization.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readBasis(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readBasis(<span class="stringliteral">&#39;myprob.bas&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .bas format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="readMipStart"></a><a class="anchor" id="ad31dee6ddcaba65cb876db53a7f5f120"></a><!-- doxytag: member="Cplex::readMipStart" ref="ad31dee6ddcaba65cb876db53a7f5f120" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readMipStart </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a MST file and copies the information of all the MIP starts contained in this file into a <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. </p>
<p>The parameter <code>advance</code> must be set to 1 (one), its default value, or 2 (two) in order for the MIP starts to be used.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readMipStart(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readMipStart(<span class="stringliteral">&#39;myprob.mst&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .mst format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="readModel"></a><a class="anchor" id="aee82fdc2fa98016a29e34781ff9f1a78"></a><!-- doxytag: member="Cplex::readModel" ref="aee82fdc2fa98016a29e34781ff9f1a78" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readModel </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a CPLEX model from a file and copies it into the invoking object. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readModel(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readModel(<span class="stringliteral">&#39;myprob.lp&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - The filename must end in one of these suffixes: .lp, .mps, .sav and .gz.</td></tr>
  </table>
  </dd>
</dl>
<p>See also the example lpex2.m. </p>

</div>
</div>
<a name="readOrder"></a><a class="anchor" id="ae30820da44dfd1e2ad8a1fc936ccd675"></a><!-- doxytag: member="Cplex::readOrder" ref="ae30820da44dfd1e2ad8a1fc936ccd675" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readOrder </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a priority order file from the file specified by filename. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readOrder(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readOrder(<span class="stringliteral">&#39;Order.ord&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .ord format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="readParam"></a><a class="anchor" id="ad295203385eb6a86120d8be827b0a1b8"></a><!-- doxytag: member="Cplex::readParam" ref="ad295203385eb6a86120d8be827b0a1b8" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readParam </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads parameters names and settings from the file specified by filename and copies them into the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> object. </p>
<p>This routine reads and copies files in the PRM format, as created by <code>cplex.writeParam</code>. The PRM format is documented in the CPLEX File Formats manual.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readParam(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.readParam(<span class="stringliteral">&#39;myprob.prm&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .prm format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="refineConflict"></a><a class="anchor" id="a081a17ace1419d16524c38260447f049"></a><!-- doxytag: member="Cplex::refineConflict" ref="a081a17ace1419d16524c38260447f049" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">refineConflict </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identifies a minimal conflict for the infeasibility of the linear constraints and the variable bounds in the current linear problem. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.refineConflict()
</pre></div></dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em><a class="el" href="classCplex.html#ae89be875a50e01094ab91b97f89b3877" title="A dynamic property of the Cplex class that represents the conflict of the model.">Cplex.Conflict</a></em>&nbsp;</td><td>- Structure array as described in <a class="el" href="classCplex.html#ae89be875a50e01094ab91b97f89b3877" title="A dynamic property of the Cplex class that represents the conflict of the model.">Cplex.Conflict</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="refineMipStartConflict"></a><a class="anchor" id="ae562fd5c8b4406706965d787ea8fb81c"></a><!-- doxytag: member="Cplex::refineMipStartConflict" ref="ae562fd5c8b4406706965d787ea8fb81c" args="(cpx, index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">refineMipStartConflict </td>
          <td>(</td>
          <td class="paramtype">index</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refines a Conflict in order to determine why a given MIP start is not feasible in the linear problem. </p>
<p>This routine identifies a minimal conflict for the infeasibility of the linear constraints and bounds in a MIP start.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.refineMipStartConflict(index)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.refineMipStartConflict(index)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>index</em>&nbsp;</td><td>Int32 - Index of the MIP start among all the MIP starts associated with the problem.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em><a class="el" href="classCplex.html#ae89be875a50e01094ab91b97f89b3877" title="A dynamic property of the Cplex class that represents the conflict of the model.">Cplex.Conflict</a></em>&nbsp;</td><td>- Structure array as described in <a class="el" href="classCplex.html#ae89be875a50e01094ab91b97f89b3877" title="A dynamic property of the Cplex class that represents the conflict of the model.">Cplex.Conflict</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="setDefault"></a><a class="anchor" id="ab4a9813badf88d74de0c06acab634e14"></a><!-- doxytag: member="Cplex::setDefault" ref="ab4a9813badf88d74de0c06acab634e14" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setDefault </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets all CPLEX parameters and settings to default values. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.setDefault()
</pre></div></dd></dl>
<p>See also the example lpex1.m. </p>

</div>
</div>
<a name="solve"></a><a class="anchor" id="afd2f5388375d7bcf5257b72d59b69687"></a><!-- doxytag: member="Cplex::solve" ref="afd2f5388375d7bcf5257b72d59b69687" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">solve </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the current model in the invoking object. </p>
<p>After a call to solve, the field <code>Solution</code> of the invoking object will be populated as well as the field <code>Start</code> for an LP or <code>MipStart</code> for a MIP.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.solve()
</pre></div></dd></dl>
<p>See also the example lpex1.m. </p>

</div>
</div>
<a name="terminate"></a><a class="anchor" id="a9673667bb52ed7b189146b1cdafc4ac7"></a><!-- doxytag: member="Cplex::terminate" ref="a9673667bb52ed7b189146b1cdafc4ac7" args="(cpx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">terminate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interrupts an ongoing <a class="el" href="classCplex.html#afd2f5388375d7bcf5257b72d59b69687" title="Solves the current model in the invoking object.">solve()</a> method invocation. </p>
<p>Use this method to implement stop buttons for a GUI.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.terminate()
</pre></div> </dd></dl>

</div>
</div>
<a name="tuneParam"></a><a class="anchor" id="a14f2446347591c067dea9b4f68961508"></a><!-- doxytag: member="Cplex::tuneParam" ref="a14f2446347591c067dea9b4f68961508" args="(cpx, varargin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuneParam </td>
          <td>(</td>
          <td class="paramtype">varargin</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tunes the parameters of the environment for improved optimizer performance on the specified problem object. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.tuneParam(param)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd>Tune all parameters: <div class="fragment"><pre class="fragment"> cplex.tuneParam();
</pre></div> Tune parameters while keeping <code>cplex.Param.mip.strategy.heuristicfreq</code> and <code>cplex.Param.mip.strategy.branch</code> unchanged: <div class="fragment"><pre class="fragment"> cplex.tuneParam({cplex.Param.mip.strategy.heuristicfreq,...
                  cplex.Param.mip.strategy.branch)
</pre></div> Tune parameters with keeping parameters in <code>cplex.Param.mip.cuts</code> unchanged: <div class="fragment"><pre class="fragment"> cplex.tuneParam(cplex.Param.mip.cuts)
</pre></div> </dd></dl>

</div>
</div>
<a name="writeBasis"></a><a class="anchor" id="a1864da014e0a765269c7aabc17bbef94"></a><!-- doxytag: member="Cplex::writeBasis" ref="a1864da014e0a765269c7aabc17bbef94" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeBasis </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the most current basis associated with a <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object to a file. </p>
<p>The file is saved in BAS format which corresponds to the industry standard MPS insert format for bases.</p>
<p>When <code>writeBasis</code> is invoked, the current basis is written to a file. This routine does not remove the basis from the problem object.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeBasis(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeBasis(<span class="stringliteral">&#39;myprob.bas&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .bas format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="writeConflict"></a><a class="anchor" id="a6b2430fc2b7cfc4e9346268c2b530434"></a><!-- doxytag: member="Cplex::writeConflict" ref="a6b2430fc2b7cfc4e9346268c2b530434" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeConflict </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a Conflict file named filename. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeConflict(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeConflict(<span class="stringliteral">&#39;Conflict.lp&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .lp format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="writeMipStart"></a><a class="anchor" id="a9a4d7f60d726bbadd9b730232061524f"></a><!-- doxytag: member="Cplex::writeMipStart" ref="a9a4d7f60d726bbadd9b730232061524f" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeMipStart </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a range of MIP starts of a <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object to a file in MST format. </p>
<p>The MST format is an XML format and is documented in the stylesheet solution.xsl and schema solution.xsd in the include directory of the CPLEX distribution. CPLEX File Formats also documents this format briefly.</p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeMipStart(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeMipStart(<span class="stringliteral">&#39;myprob.mst&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .mst format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="writeModel"></a><a class="anchor" id="a7dd8b7dd831720ee8e53a41fe1e00f42"></a><!-- doxytag: member="Cplex::writeModel" ref="a7dd8b7dd831720ee8e53a41fe1e00f42" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeModel </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the CPLEX model of the invoking object to a file. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeModel(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeModel(<span class="stringliteral">&#39;myprob.lp&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file with one of the formats: </p>
<table class="doxtable">
<tr>
<th>File Suffix </th><th>format  </th></tr>
<tr>
<td>.mps  </td><td>MPS format   </td></tr>
<tr>
<td>.lp  </td><td>CPLEX LP format with names modified to conform to LP format   </td></tr>
<tr>
<td>.sav  </td><td>Binary matrix and basis file   </td></tr>
<tr>
<td>.rew  </td><td>MPS format with all names changed to generic names   </td></tr>
<tr>
<td>.rlp  </td><td>LP format, with all names changed to generic names   </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="writeOrder"></a><a class="anchor" id="ab46bca65f65d084b09f556f70cef91a3"></a><!-- doxytag: member="Cplex::writeOrder" ref="ab46bca65f65d084b09f556f70cef91a3" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeOrder </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a priority order file into the file specified by filename. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeOrder(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeOrder(<span class="stringliteral">&#39;Order.ord&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .ord format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="writeParam"></a><a class="anchor" id="a5d37e011bca6e7c2f05ca0405f144382"></a><!-- doxytag: member="Cplex::writeParam" ref="a5d37e011bca6e7c2f05ca0405f144382" args="(cpx, filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeParam </td>
          <td>(</td>
          <td class="paramtype">filename</td>
          <td class="paramname"></td>
          <td>)</td>
<td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the parameter names and their current settings into the file specified by filename for all the CPLEX parameters that are not currently set at their default values. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeParam(filename)
</pre></div></dd></dl>
<dl class="user"><dt><b>Examples:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.writeParam(<span class="stringliteral">&#39;myprob.prm&#39;</span>)
</pre></div></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td class="docparamname" valign="top"><em>filename</em>&nbsp;</td><td>String - A file in the .prm format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Property detail</h2>
<a name="Conflict"></a><a class="anchor" id="ae89be875a50e01094ab91b97f89b3877"></a><!-- doxytag: member="Cplex::Conflict" ref="ae89be875a50e01094ab91b97f89b3877" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Conflict</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the conflict of the model. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">   cplex.Conflict.status
   ...
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>A conflict is a set of mutually contradictory constraints and bounds within a model. Given an infeasible model, CPLEX&reg; can identify conflicting constraints and bounds within it. CPLEX refines an infeasible model by examining elements that can be removed from the conflict to arrive at a minimal conflict. A conflict smaller than the full model may make it easier for the user to analyze the source of infeasibilities in the original model. If the model happens to contain multiple independent causes of infeasibility, it may be necessary for the user to repair one cause and then repeat the process with a further refinement.</dd></dl>
<p>The structure <code><a class="el" href="classCplex.html#ae89be875a50e01094ab91b97f89b3877" title="A dynamic property of the Cplex class that represents the conflict of the model.">Cplex.Conflict</a></code> is a dynamic data property of a <code><a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a></code> object. This property is generated when the method <code><a class="el" href="classCplex.html#a081a17ace1419d16524c38260447f049" title="Identifies a minimal conflict for the infeasibility of the linear constraints and...">Cplex.refineConflict</a></code> or <code>cplex.refineMipStartConflict</code> (if the model is a MIP) is called. This property representing the solution is updated by the methods of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> object and should not be created or edited otherwise.</p>
<p>Use <code>cplex.findprop('Conflict').delete</code> to remove this property.</p>
<dl class="user"><dt><b>Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>colind </td><td>Int32 column vector </td><td>Vector to receive the list of the indices of the variables that participate in the Conflict. The length of the vector must not be less than the number of columns in the Conflict. If that number is not known, use the number of columns in the problem object instead.  </td></tr>
<tr>
<td>colbdstat </td><td>Int32 column vector </td><td>Vector to receive the Conflict status of the columns. Entry colbdstat(i) gives the status of column colind(i). The length of the vector must not be less than the number of columns in the Conflict. If that number is not known, use the number of columns in the problem object instead.  </td></tr>
<tr>
<td>rowind </td><td>Int32 column vector </td><td>Vector to receive the list of the indices of the constraints that participate in the Conflict. The length of the vector must not be less than the number of rows in the Conflict. If that number is not known, use the total number of rows in the problem object instead.  </td></tr>
<tr>
<td>rowbdstat </td><td>Int32 column vector </td><td>Vector to receive the Conflict status of the rows. Entry rowbdstat(i) gives the status of row rowind(i). The length of the vector must not be less than the number of rows in the Conflict. If that number is not known, use the number of rows in the problem object instead.  </td></tr>
<tr>
<td>status </td><td>Int32 </td><td>Status of the Conflict.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b>Conflict status values:</b></dt><dd><table class="doxtable">
<tr>
<th>Status </th><th>Meaning  </th></tr>
<tr>
<td>30 </td><td>The problem appears to be feasible; no conflict is available.  </td></tr>
<tr>
<td>31 </td><td>The conflict refiner found a minimal conflict.  </td></tr>
<tr>
<td>32 </td><td>The conflict refiner concluded contradictory feasibility for the same set of constraints due to numeric problems. A conflict is available, but it is not minimal.   </td></tr>
<tr>
<td>33 </td><td>The conflict refiner terminated because of a time limit. A conflict is available, but it is not minimal.  </td></tr>
<tr>
<td>34 </td><td>The conflict refiner terminated because of an iteration limit. A conflict is available, but it is not minimal.  </td></tr>
<tr>
<td>35 </td><td>The conflict refiner terminated because of a node limit. A conflict is available, but it is not minimal.  </td></tr>
<tr>
<td>36 </td><td>The conflict refiner terminated because of an objective limit. A conflict is available, but it is not minimal.   </td></tr>
<tr>
<td>37 </td><td>The conflict refiner terminated because of a memory limit. A conflict is available, but it is not minimal.  </td></tr>
<tr>
<td>38 </td><td>The conflict refiner terminated because a user terminated the application. A conflict is available, but it is not minimal.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a name="DisplayFunc"></a><a class="anchor" id="ad15aa55e15ab198965472a5517db380b"></a><!-- doxytag: member="Cplex::DisplayFunc" ref="ad15aa55e15ab198965472a5517db380b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DisplayFunc</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that is a pointer to a function which provides control of display of output. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a>.DisplayFunc
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>The default value of this property is <code></code>, the function handle of the display function in MATLAB&reg;. With the default, all of the log information from CPLEX will be displayed. If the <code><a class="el" href="classCplex.html#ad15aa55e15ab198965472a5517db380b" title="A property of the Cplex class that is a pointer to a function which provides control...">Cplex.DisplayFunc</a></code> property is set to empty, then the log information from CPLEX will not be displayed. In addition, users can write a custom <code>DisplayFunc</code> to control the output. </dd></dl>

</div>
</div>
<a name="InfoCallback"></a><a class="anchor" id="adde752cbaa0027277c16f0a69c02d893"></a><!-- doxytag: member="Cplex::InfoCallback" ref="adde752cbaa0027277c16f0a69c02d893" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InfoCallback</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that is a pointer to an informational callback. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">   cplex.InfoCallback.func
   cplex.InfoCallback.data
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>An informational callback is a user-written routine that enables your application to access information about the current mixed integer programming (MIP) optimization without sacrificing performance and without interfering in the search of the solution space. The algorithms call an informational callback when the algorithm finds it appropriate; for some algorithms, an informational callback is called at every node; for other algorithms, an informational callback is called at convenient points in the progress of the algorithm. Information returned by informational callbacks summarizes the information that an informational callback can return.</dd></dl>
<p>An informational callback can also enable your application to abort (that is, to terminate) optimization. Informational callbacks are compatible with MIP dynamic search. For many models, MIP dynamic search finds feasible and optimal solutions more quickly than conventional MIP branch &amp; cut.</p>
<p>Use <code>cplex.findprop('InfoCallback').delete</code> to remove this property.</p>
<dl class="user"><dt><b>Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>func </td><td>Handle </td><td>Handle of the user-defined callback function.  </td></tr>
<tr>
<td>data </td><td>Struct </td><td>Structure for data, for which the users can define the fields.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a name="MipStart"></a><a class="anchor" id="ae5bccc8c64cd3b710aa367c386de6650"></a><!-- doxytag: member="Cplex::MipStart" ref="ae5bccc8c64cd3b710aa367c386de6650" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MipStart</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the MipStart of the MIP model. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">   cplex.MipStart(i).name
   cplex.MipStart(i).effortlevel
   cplex.MipStart(i).x
   cplex.MipStart(i).xindices
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the <code>MipStart</code> of the MIP model; it will be generated after solving. <code>MipStart</code> is a structure array which can contain many starts. It also can be given before solving to help the optimizer get a <code>Solution</code>. It is optional.</dd></dl>
<p>Use <code>cplex.findprop('MipStart').delete</code> to remove this property.</p>
<dl class="user"><dt><b>Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>name </td><td>String </td><td>Name of this mipstart.  </td></tr>
<tr>
<td>effortlevel </td><td>Int32 </td><td><p class="starttd">Level of effort CPLEX&reg; should exert to solve this mipstart: </p>
<table  cellpadding="5">
<tr>
<td>0 </td><td>Automatic, CPLEX decides.  </td></tr>
<tr>
<td>1 </td><td>CPLEX checks the feasibility of the mipstart.  </td></tr>
<tr>
<td>2 </td><td>CPLEX solves the fixed LP specified by the mipstart.  </td></tr>
<tr>
<td>3 </td><td>CPLEX solves a subMIP.  </td></tr>
<tr>
<td>4 </td><td>CPLEX attempts to repair the MIP start if it is infeasible, according to the parameter that sets the frequency to try to repair infeasible MIP start, CPX_PARAM_REPAIRTRIES.   </td></tr>
</table>
<p class="endtd">By default, CPLEX expends effort at level 4 for the incumbent and at level 1 (one) for a solution corresponding to a solution in the solution pool. The user may change the level of effort. A user may specify a different level of effort for each MIP start, for example, differing levels of effort for the incumbent, for a mipstart corresponding to a solution in the solution pool, for a mipstart supplied by the user.  </p>
</td></tr>
<tr>
<td>x </td><td>Double column vector </td><td>Vector containing the initial primal values of the column variables.  </td></tr>
<tr>
<td>xindices </td><td>Int32 column vector </td><td>Vector indicating the list of the indices of the variables that have initial primal values.  </td></tr>
</table>
</dd></dl>

</div>
</div>
<a name="Model"></a><a class="anchor" id="a051e4d035e053a4636efc58c1bde9b3e"></a><!-- doxytag: member="Cplex::Model" ref="a051e4d035e053a4636efc58c1bde9b3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the model used by the math programming solver. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">         cplex.Model.name
         cplex.Model.sense
          ... 
</pre></div> </dd></dl>
<dl class="user"><dt><b>Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>name </td><td>String </td><td>Name of the model.  </td></tr>
<tr>
<td>sense </td><td>String </td><td>String that specifies whether the problem is a minimization or maximization problem.  </td></tr>
<tr>
<td>obj </td><td>Double column vector </td><td>Objective function coefficients.  </td></tr>
<tr>
<td>lb </td><td>Double column vector </td><td>Lower bound on each of the variables.  </td></tr>
<tr>
<td>ub </td><td>Double column vector </td><td>Upper bound on each of the variables.  </td></tr>
<tr>
<td>A </td><td>Double matrix </td><td>Constraint matrix.  </td></tr>
<tr>
<td>lhs </td><td>Double column vector </td><td>Lefthand side value for each constraint in the constraint matrix.  </td></tr>
<tr>
<td>rhs </td><td>Double column vector </td><td>Righthand side value for each constraint in the constraint matrix.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b>Optional Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description </th></tr>
<tr>
<td>objname </td><td>String </td><td>Name of the objective.  </td></tr>
<tr>
<td>colname </td><td>Char matrix </td><td>Names of the matrix columns or, equivalently, the variable names.  </td></tr>
<tr>
<td>rowname </td><td>Char matrix </td><td>Names of the matrix rows or, equivalently, the constraint names.  </td></tr>
<tr>
<td>ctype </td><td>String </td><td>Type of each column in the constraint matrix, specifying whether a variable is continuous, integer, binary, semi-continuous or semi-integer. The possible char vales are 'B','I','C','S','N'. Set ctype(j) to 'B', 'I','C', 'S', or 'N' to indicate that x(j) should be binary, general integer, continuous, semi-continuous or semi-integer (respectively).  </td></tr>
<tr>
<td>sos </td><td>Struct array </td><td>Represents the SOSs.  </td></tr>
<tr>
<td>sos(i).name </td><td>String </td><td>(Optional) Name of SOS j.  </td></tr>
<tr>
<td>sos(i).type </td><td>Char </td><td>Type of SOS j; char '1' or '2'.  </td></tr>
<tr>
<td>sos(i).ind </td><td>Double column vector </td><td>Index of SOS to be added  </td></tr>
<tr>
<td>sos(i).wt </td><td>Double column vector </td><td>Weights for the SOS to be added.  </td></tr>
<tr>
<td>Q </td><td>Double matrix </td><td>Quadratic objective matrix.  </td></tr>
<tr>
<td>qc </td><td>Struct array </td><td>Represents the quadratic constraints.  </td></tr>
<tr>
<td>qc(i).name </td><td>String </td><td>(Optional) Name of quadratic constraint.  </td></tr>
<tr>
<td>qc(i).sense </td><td>Char </td><td>Sense of quadratic constraint (char 'L' or 'G',   </td></tr>
<tr>
<td>qc(i).a </td><td>Double column vector </td><td>Linear part of the quadratic constraint.  </td></tr>
<tr>
<td>qc(i).rhs </td><td>Double </td><td>Righthand side term for the constraint.  </td></tr>
<tr>
<td>qc(i).Q </td><td>Double matrix </td><td><p class="starttd">Quadratic part of the quadratic constraint.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>indicator </td><td>Struct array </td><td><p class="starttd">Represents the indicator constraints.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>indicator(i).name </td><td>String </td><td><p class="starttd">(Optional) Name.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>indicator(i).variable </td><td>Binary variable </td><td><p class="starttd">Acts as the indicator for the constraint.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>indicator(i).complement </td><td>Boolean value </td><td><p class="starttd">Specifies whether the indicator variable is complemented.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>indicator(i).a </td><td>Double column vector </td><td><p class="starttd">Linear portion of the indicator constraint.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>indicator(i).rhs </td><td>Double </td><td><p class="starttd">Righthand side value for the linear portion of the indicator constraint.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>indicator(i).sense </td><td>Char </td><td><p class="starttd">char 'L','G' or 'E'.</p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>

</div>
</div>
<a name="Order"></a><a class="anchor" id="afbb7a18945a0832b5189bbe768dd0c51"></a><!-- doxytag: member="Cplex::Order" ref="afbb7a18945a0832b5189bbe768dd0c51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Order</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the priority order. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">    cplex.Order.ind
    cplex.Order.pri
    cplex.Order.dir
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>During branching, integer variables with higher priorities are given preference over integer variables with lower priorities. Further, variables that have priority assigned to them are given preference over variables that do not. Priorities must be nonnegative integers. By default, the priority of a variable without a user-assigned priority is 0 (zero).</dd></dl>
<p>Use <code>cplex.findprop('Order').delete</code> to remove this property.</p>
<dl class="user"><dt><b>Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>ind </td><td>Int32 column vector </td><td>Vector containing the indicies of the variables.  </td></tr>
<tr>
<td>pri </td><td>Int32 column vector </td><td>Vector containing the priority order values of the corresponding variables.   </td></tr>
<tr>
<td>dir </td><td>Int32 column vector </td><td>The preferred branching direction of the corresponding variable. This will cause CPLEX first to explore the branch specified by dir(i) after branching on variable x(i). The possible values are: CPX_BRANCH_GLOBAL, CPX_BRANCH_DOWN, CPX_BRANCH_UP.   </td></tr>
</table>
</dd></dl>

</div>
</div>
<a name="Param"></a><a class="anchor" id="a56d92885c62355169101500c45638e29"></a><!-- doxytag: member="Cplex::Param" ref="a56d92885c62355169101500c45638e29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Param</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the parameters for the math programming solver. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment"> cplex.Param.lpmethod
 ...
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>The behavior of CPLEX is controlled by a variety of parameters that can be accessed and modified by the user. Each parameter is a field of the <code><a class="el" href="classCplex.html#a56d92885c62355169101500c45638e29" title="A property of the Cplex class that represents the parameters for the math programming...">Cplex.Param</a></code> structure. The fields of each parameter are described in the following table.</dd></dl>
<table class="doxtable">
<tr>
<th>Field </th><th>Description  </th></tr>
<tr>
<td>Cur </td><td>Current value of the parameter.  </td></tr>
<tr>
<td>Def </td><td>Default value of the parameter.  </td></tr>
<tr>
<td>Min </td><td>(Optional.) Min possible value of the parameter.  </td></tr>
<tr>
<td>Max </td><td>(Optional.) Max possible value of the parameter.  </td></tr>
<tr>
<td>Name </td><td>Name value of the parameter.  </td></tr>
<tr>
<td>Help </td><td>Help value of the parameter.  </td></tr>
</table>
<p>For the usage of each parameter please refer to the CPLEX Parameters Reference Manual.</p>
<dl class="user"><dt><b>Examples:</b></dt><dd></dd></dl>
<p>Set a parameter: </p>
<div class="fragment"><pre class="fragment"> cplex.Param.lpmethod.Cur=5
</pre></div><p> Get a parameter: </p>
<div class="fragment"><pre class="fragment"> cplex.Param.lpmethod.Cur
</pre></div><p> Set a node limit of 400 and instruct CPLEX to use traditional branch and cut style search: </p>
<div class="fragment"><pre class="fragment"> cplex.Param.mip.limits.nodes.Cur=400;
 cplex.Param.mip.strategy.search.Cur=1;
</pre></div><dl class="user"><dt><b>Tip:</b></dt><dd>If you are already familiar with the names of parameters in the Interactive Optimizer, then you quickly recognize names of parameters in CPLEX for MATLAB&reg;. For example, the command set mip limits nodes 1 in the Interactive Optimizer corresponds to <code>cplex.Param.mip.limits.nodes.Cur = 1;</code> in the CPLEX Class API where cplex is an instance of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class.</dd></dl>
<p>To assist in setting parameters, auto-completion of parameter names is available in the MATLAB environment. </p>

</div>
</div>
<a name="Solution"></a><a class="anchor" id="a93e3891009533aaefce016703acb30d4"></a><!-- doxytag: member="Cplex::Solution" ref="a93e3891009533aaefce016703acb30d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Solution</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the solution of the model. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">   cplex.Solution.status
   cplex.Solution.statusstring
   ...
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>This dynamic property representing the solution is generated and updated by the <code>solve</code> or <code>feasopt</code> methods of the <code><a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a></code> object and should not be created or edited otherwise. If the Model is a MIP, <code>populate</code> can generate Solution as well. Not all entries will appear after an optimization. Some depend on the problem type, some on the solution status, and some do not appear if they have a null value.</dd></dl>
<p>Use <code>cplex.findprop('Solution').delete</code> to remove this property.</p>
<dl class="user"><dt><b>Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description </th></tr>
<tr>
<td>status </td><td>Int32 </td><td>Status code of the solution. </td></tr>
<tr>
<td>statusstring </td><td>String </td><td>Status string of the solution. </td></tr>
<tr>
<td>time </td><td>Double </td><td>Execution time of the algorithm.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b>Optional fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>objval </td><td>Double </td><td>Objective value.  </td></tr>
<tr>
<td>x </td><td>Double column vector </td><td>Vector representing the optimal value of variables.  </td></tr>
<tr>
<td>ax </td><td>Double column vector </td><td>Vector representing the product of the optimal value of variables and the constraint matrix.  </td></tr>
<tr>
<td>method </td><td>Int32 </td><td>Integer representing the method solving the problem.  </td></tr>
<tr>
<td>reducedcost </td><td>Double column vector </td><td>Reduced costs for a linear, quadratic or second order cone problem.  </td></tr>
<tr>
<td>dual </td><td>Double column vector </td><td>"Dual values for a range of the linear constraints of a linear, quadratic or second order cone program.  </td></tr>
<tr>
<td>basis </td><td>Struct </td><td>Structure with fields <code>colstat</code> and <code>rowstat</code>.  </td></tr>
<tr>
<td>basis.colstat </td><td>Int32 column vector </td><td>Vector representing the column status of basis.  </td></tr>
<tr>
<td>basis.rowstat </td><td>Int32 column vector </td><td>Vector representing the row status of basis.  </td></tr>
<tr>
<td>itcnt </td><td>Int32 </td><td>Total number of simplex iterations to solve an LP problem, or the number of crossover iterations in the case that the barrier optimizer is used.  </td></tr>
<tr>
<td>baritcnt </td><td>Int32 </td><td>Total number of Barrier iterations to solve an LP problem.  </td></tr>
<tr>
<td>phase1cnt </td><td>Int32 </td><td>Number of Phase 1 iterations to solve a problem using the primal or dual simplex method.  </td></tr>
<tr>
<td>siftitcnt </td><td>Int32 </td><td>Total number of sifting iterations to solve an LP problem.  </td></tr>
<tr>
<td>siftphase1cnt </td><td>Int32 </td><td>Number of Phase 1 sifting iterations to solve an LP problem.  </td></tr>
<tr>
<td>mipitcnt </td><td>Int32 </td><td>Cumulative number of simplex iterations used to solve a mixed integer problem.  </td></tr>
<tr>
<td>nodecnt </td><td>Int32 </td><td>Number of nodes used to solve a mixed integer problem.  </td></tr>
<tr>
<td>crossppushcnt </td><td>Int32 </td><td>Number of primal push iterations in the crossover method.  </td></tr>
<tr>
<td>crosspexchcnt  </td><td>Int32 </td><td>Number of primal exchange iterations in the crossover method.  </td></tr>
<tr>
<td>crossdpushcnt  </td><td>Int32 </td><td>Number of dual push iterations in the crossover method.  </td></tr>
<tr>
<td>crossdexchcnt  </td><td>Int32 </td><td>Number of dual exchange iterations in the crossover method.  </td></tr>
<tr>
<td>bestobjval </td><td>Double </td><td>Currently best known objective value of a MIP problem.  </td></tr>
<tr>
<td>nodeint </td><td>Int32 </td><td>Node number of the best known integer solution.  </td></tr>
<tr>
<td>miprelgap </td><td>Double </td><td>Current best known relative objective gap for a MIP optimization.  </td></tr>
<tr>
<td>cutoff </td><td>Double </td><td>Cutoff value being used during mixed integer optimization; the cutoff is updated with the objective function value each time an integer solution is found during branch &amp; cut.  </td></tr>
<tr>
<td>nodeleftcnt </td><td>Int32 </td><td>Number of unexplored nodes left in the branch &amp; cut tree.  </td></tr>
<tr>
<td>indicatorax </td><td>Double column vector </td><td>Vector representing the product of the optimal value of variables and the indicator constraint matrix. Values of <code>-Inf</code> mark constraints that are inactive.  </td></tr>
<tr>
<td>pool </td><td>Struct </td><td>Structure with fields <code>meanob</code> and <code>solution</code>.  </td></tr>
<tr>
<td>pool.meanobj  </td><td>Double </td><td>Mean of the objective values of all solutions in the solution pool.  </td></tr>
<tr>
<td>pool.solution </td><td>Struct array </td><td>Structure array with fields <code>quality</code>, <code>objval</code>, <code>x</code> and <code>ax</code>. The <code>quality</code> struct for pool.solution(i) has the same fields as <code>Cplex.Solution.quality</code>.  </td></tr>
<tr>
<td>pool.solution(i).objval  </td><td>Double </td><td>Objective value of the i-th solution.  </td></tr>
<tr>
<td>pool.solution(i).x </td><td>Double column vector </td><td>Solution values of the i-th solution.  </td></tr>
<tr>
<td>pool.solution(i).ax </td><td>Double column vector </td><td>Product of the solution values of the i-th solution and the constraint matrix.  </td></tr>
<tr>
<td>quality </td><td>Struct </td><td>Structure with fields which describe the quality of the solution  </td></tr>
<tr>
<td>quality.maxprimalinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <em>CPLEX Callable Library Reference Manual</em> entry for <code>CPX_MAX_PRIMAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.maxscaledprimalinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_PRIMAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.sumprimalinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_PRIMAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.sumscaledprimalinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_PRIMAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.maxprimalresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_PRIMAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.maxscaledprimalresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_PRIMAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.sumprimalresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_PRIMAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.sumscaledprimalresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_PRIMAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.maxx </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_X</code>.  </td></tr>
<tr>
<td>quality.maxscaledx </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_X</code>.  </td></tr>
<tr>
<td>quality.maxslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SLACK</code>.  </td></tr>
<tr>
<td>quality.maxscaledslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_SLACK</code>.  </td></tr>
<tr>
<td>quality.sumx </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_X</code>.  </td></tr>
<tr>
<td>quality.sumscaledx </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_X</code>.  </td></tr>
<tr>
<td>quality.sumslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SLACK</code>.  </td></tr>
<tr>
<td>quality.sumscaledslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_SLACK</code>.  </td></tr>
<tr>
<td>quality.maxintinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_INT_INFEAS</code>.  </td></tr>
<tr>
<td>quality.sumintinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_INT_INFEAS</code>.  </td></tr>
<tr>
<td>quality.maxqcprimalresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_QCPRIMAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.sumqcprimalresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_QCPRIMAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.maxqcslackinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_QCSLACK_INFEAS</code>.  </td></tr>
<tr>
<td>quality.sumqcslackinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_QCSLACK_INFEAS</code>.  </td></tr>
<tr>
<td>quality.maxqcslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_QCSLACK</code>.  </td></tr>
<tr>
<td>quality.sumqcslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_QCSLACK</code>.  </td></tr>
<tr>
<td>quality.maxindslackinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_INDSLACK_INFEAS</code>.  </td></tr>
<tr>
<td>quality.sumindslackinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_INDSLACK_INFEAS</code>.  </td></tr>
<tr>
<td>quality.maxdualinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_DUAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.maxscaleddualinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_DUAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.sumdualinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_DUAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.sumscaleddualinfeas </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_DUAL_INFEAS</code>.  </td></tr>
<tr>
<td>quality.maxdualresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_DUAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.maxscaleddualresidual </td><td>SStruct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_DUAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.sumdualresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_DUAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.sumscaleddualresidual </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_DUAL_RESIDUAL</code>.  </td></tr>
<tr>
<td>quality.maxpi </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_PI</code>.  </td></tr>
<tr>
<td>quality.maxscaledpi </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_PI</code>.  </td></tr>
<tr>
<td>quality.maxredcost </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_RED_COST</code>.  </td></tr>
<tr>
<td>quality.maxscaledredcost </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_SCALED_RED_COST</code>.  </td></tr>
<tr>
<td>quality.sumpi </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_PI</code>.  </td></tr>
<tr>
<td>quality.sumscaledpi </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_PI</code>.  </td></tr>
<tr>
<td>quality.sumredcost </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_RED_COST</code>.  </td></tr>
<tr>
<td>quality.sumscaledredcost </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_SCALED_RED_COST</code>.  </td></tr>
<tr>
<td>quality.maxcompslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_MAX_COMP_SLACK</code>.  </td></tr>
<tr>
<td>quality.sumcompslack </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_SUM_COMP_SLACK</code>.  </td></tr>
<tr>
<td>quality.kappa </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_KAPPA</code>.  </td></tr>
<tr>
<td>quality.exactkappa </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_EXACT_KAPPA</code>.  </td></tr>
<tr>
<td>quality.objgap </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_OBJ_GAP</code>.  </td></tr>
<tr>
<td>quality.dualobj </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_DUAL_OBJ</code>.  </td></tr>
<tr>
<td>quality.primalobj </td><td>Struct with fields Double (value) and optional Int32 (ind) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_PRIMAL_OBJ</code>.  </td></tr>
<tr>
<td>quality.kappastable </td><td>Struct with fields Double (value) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_KAPPA_STABLE</code>.  </td></tr>
<tr>
<td>quality.kappasuspicious </td><td>Struct with fields Double (value) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_KAPPA_SUSPICIOUS</code>.  </td></tr>
<tr>
<td>quality.kappaunstable </td><td>Struct with fields Double (value) </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_KAPPA_UNSTABLE</code>.  </td></tr>
<tr>
<td>quality.kappaillposed </td><td>Struct with fields Double (value)  </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_KAPPA_ILLPOSED</code>.  </td></tr>
<tr>
<td>quality.kappamax </td><td>Struct with fields Double (value)  </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_KAPPA_MAX</code>.  </td></tr>
<tr>
<td>quality.kappaattention  </td><td>Struct with fields Double (value)  </td><td>For detailed information, see the <span class="italics">CPLEX Callable Library Reference Manual</span> entry for <code>CPX_KAPPA_ATTENTION</code>.  </td></tr>
</table>
</dd></dl>
<table  class="usertable">
<tr>
<th>Solution value </th><th>Meaning  </th></tr>
<tr>
<td><p class="starttd">1</p>
<p class="endtd"></p>
</td><td>(Simplex or Barrier) Optimal solution is available.  </td></tr>
<tr>
<td>2 </td><td>(Simplex or Barrier) Problem has an unbounded ray; see the concept Unboundedness for more information about infeasibility and unboundedness as a solution status.   </td></tr>
<tr>
<td>3 </td><td><p class="starttd">Simplex or Barrier) Problem has been proven infeasible; see the topic Interpreting Solution Quality in the <span class="italics">IBM ILOG CPLEX User's Manual</span> for more details. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>4 </td><td>(Simplex or Barrier) Problem has been proven either infeasible or unbounded; see the topic Effect of Preprocessing on Feasibility in the <span class="italics">IBM ILOG CPLEX User's Manual</span> for more details.   </td></tr>
<tr>
<td>5 </td><td>(Simplex or Barrier) Optimal solution is available, but with infeasibilities after unscaling.  </td></tr>
<tr>
<td>6 </td><td>(Simplex or Barrier) Solution is available, but not proved optimal, due to numeric difficulties during optimization.   </td></tr>
<tr>
<td>10 </td><td>Stopped due to limit on number of iterations. (Simplex or Barrier)  </td></tr>
<tr>
<td>11 </td><td><p class="starttd">(Simplex or Barrier) Stopped due to a time limit. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>12 </td><td>(Simplex or Barrier) Stopped due to an objective limit.  </td></tr>
<tr>
<td>13 </td><td>(Simplex or Barrier) Stopped due to a request from the user.  </td></tr>
<tr>
<td>14 </td><td><p class="starttd">Simplex or Barrier) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_MIN_SUM (or MinSum) on a continuous problem. A relaxation was successfully found and a feasible solution for the problem. (if relaxed according to that relaxation) was installed. The relaxation is minimal.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>15 </td><td>Simplex or Barrier) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_OPT_SUM (or OptSum) on a continuous problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is optimal.  </td></tr>
<tr>
<td>16 </td><td><p class="starttd">Simplex or Barrier) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_MIN_INF (or MinInf) on a continuous problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is minimal.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>17 </td><td>(Simplex or Barrier) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_OPT_INF (or OptInf) on a continuous problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is optimal.  </td></tr>
<tr>
<td>18 </td><td><p class="starttd">Simplex or Barrier) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_MIN_QUAD (or MinQuad) on a continuous problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is minimal.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>19 </td><td>Simplex or Barrier) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_OPT_QUAD (or OptQuad) on a continuous problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is optimal.  </td></tr>
<tr>
<td>20 </td><td>(Barrier only) Model has an unbounded optimal face   </td></tr>
<tr>
<td>21 </td><td>(Barrier only) Stopped due to a limit on the primal objective   </td></tr>
<tr>
<td>22 </td><td>(Barrier only.) Stopped due to a limit on the dual objective   </td></tr>
<tr>
<td>23 </td><td>(Simplex or Barrier) This status occurs only after a call to the method <code class="code">feasOpt</code> on a continuous problem. The problem under consideration was found to be feasible after phase 1 of <code class="code">feasOpt</code>. A feasible solution is available.   </td></tr>
<tr>
<td>24 </td><td>Solution satisfies first-order optimality conditions for a solution returned by the barrier optimizer for an indefinite QP when the solution target type parameter specifies a search for a solution that satisfies first-order optimality conditions, but is not necessarily globally optimal (value 2).   </td></tr>
<tr>
<td>30 </td><td>(conflict refiner) The problem appears to be feasible; no conflict is available.   </td></tr>
<tr>
<td>31 </td><td>(conflict refiner) The conflict refiner found a minimal conflict.   </td></tr>
<tr>
<td>32 </td><td><p class="starttd">(conflict refiner) The conflict refiner concluded contradictory feasibility for the same set of constraints due to numeric problems. A conflict is available, but it is not minimal. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>33 </td><td>(conflict refiner) The conflict refiner terminated because of a time limit. A conflict is available, but it is not minimal.   </td></tr>
<tr>
<td>34 </td><td>(conflict refiner) The conflict refiner terminated because of an iteration limit. A conflict is available, but it is not minimal.   </td></tr>
<tr>
<td>35 </td><td><p class="starttd">(conflict refiner) The conflict refiner terminated because of a node limit. A conflict is available, but it is not minimal. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>36 </td><td>(conflict refiner) The conflict refiner terminated because of an objective limit. A conflict is available, but it is not minimal.   </td></tr>
<tr>
<td>37 </td><td>(conflict refiner) The conflict refiner terminated because of a memory limit. A conflict is available, but it is not minimal.   </td></tr>
<tr>
<td>38 </td><td><p class="starttd">(conflict refiner) The conflict refiner terminated because a user terminated the application. A conflict is available, but it is not minimal. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>101 </td><td>(MIP only) Optimal integer solution has been found   </td></tr>
<tr>
<td>102 </td><td>(MIP only) Optimal solution with the tolerance defined by epgap or epagap has been found   </td></tr>
<tr>
<td>103 </td><td><p class="starttd">(MIP only) Solution is integer infeasible </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>104 </td><td>(MIP only) The limit on mixed integer solutions has been reached   </td></tr>
<tr>
<td>105 </td><td>(MIP only) Node limit has been exceeded but integer solution exists   </td></tr>
<tr>
<td>106 </td><td><p class="starttd">(MIP only) Node limit has been reached; no integer solution </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>107 </td><td>(MIP only) Time limit exceeded, but integer solution exists   </td></tr>
<tr>
<td>108 </td><td>(MIP only) Time limit exceeded; no integer solution   </td></tr>
<tr>
<td>109 </td><td><p class="starttd">(MIP only) Terminated because of an error, but integer solution exists.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>110 </td><td>(MIP only) Terminated because of an error; no integer solution.  </td></tr>
<tr>
<td>111 </td><td>(MIP only) Limit on tree memory has been reached, but an integer solution exists   </td></tr>
<tr>
<td>112 </td><td><p class="starttd">(MIP only) Limit on tree memory has been reached; no integer solution </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>113 </td><td>(MIP only) Stopped, but an integer solution exists.  </td></tr>
<tr>
<td>114 </td><td>(MIP only) Stopped; no integer solution.  </td></tr>
<tr>
<td>115 </td><td><p class="starttd">(MIP only) Problem is optimal with unscaled infeasibilities </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>116 </td><td>(MIP only) Out of memory, no tree available, integer solution exists.  </td></tr>
<tr>
<td>117 </td><td>(MIP only) Out of memory, no tree available, no integer solution.  </td></tr>
<tr>
<td>118 </td><td><p class="starttd">(MIP only) Problem has an unbounded ray </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>119 </td><td>(MIP only) Problem has been proved either infeasible or unbounded   </td></tr>
<tr>
<td>120 </td><td>(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_MIN_SUM (or MinSum) on a mixed integer problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is minimal.  </td></tr>
<tr>
<td>121 </td><td>(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_OPT_SUM (or OptSum) on a mixed integer problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is optimal.  </td></tr>
<tr>
<td>122 </td><td><p class="starttd">(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_MIN_INF (or MinInf) on a mixed integer problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is minimal. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>123 </td><td>(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_OPT_INF (or OptInf) on a mixed integer problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is optimal.  </td></tr>
<tr>
<td>124 </td><td><p class="starttd">(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code> with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_MIN_QUAD (or MinQuad) on a mixed integer problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is minimal. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>125 </td><td>(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code>with the parameter CPX_PARAM_FEASOPTMODE (or FeasOptMode) set to CPX_FEASOPT_OPT_QUAD (or OptQuad) on a mixed integer problem. A relaxation was successfully found and a feasible solution for the problem (if relaxed according to that relaxation) was installed. The relaxation is optimal.  </td></tr>
<tr>
<td>126 </td><td><p class="starttd">(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code>, when the algorithm terminates prematurely, for example after reaching a limit. This status means that a relaxed solution is available and can be queried.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>127 </td><td>(MIP only) This status occurs only after a call to the method <code class="code">feasOpt</code> on a MIP problem. The problem under consideration was found to be feasible after phase 1 of <code class="code">feasOpt</code>. A feasible solution is available. This status is also used in the status field of solution and mipstart files for solutions from the solution pool.  </td></tr>
<tr>
<td>128 </td><td><p class="starttd">(MIP only) This status occurs only after a call to the method <code class="code">populate</code> on a MIP problem. The limit on mixed integer solutions generated by populate, as specified by the parameter CPX_PARAM_POPULATELIM, has been reached.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>129 </td><td>(MIP only) This status occurs only after a call to the method <code class="code">populate</code> on a MIP problem. Populate has completed the enumeration of all solutions it could enumerate.  </td></tr>
<tr>
<td>130 </td><td><p class="starttd">(MIP only) This status occurs only after a call to the method <code class="code">populate</code> on a MIP problem. Populate has completed the enumeration of all solutions it could enumerate whose objective value fit the tolerance specified by the paramaters CPX_PARAM_SOLNPOOLAGAP and CPX_PARAM_SOLNPOOLGAP.</p>
<p class="endtd"></p>
</td></tr>
</table>

</div>
</div>
<a name="Start"></a><a class="anchor" id="aedcef5fb0e94ecd6e477e87d7bb5b13a"></a><!-- doxytag: member="Cplex::Start" ref="aedcef5fb0e94ecd6e477e87d7bb5b13a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Start</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the Start of the LP or QP model. </p>
<dl class="user"><dt><b>Syntax:</b></dt><dd><div class="fragment"><pre class="fragment">    cplex.Start.x
    cplex.Start.Ax
    ...
</pre></div></dd></dl>
<dl class="user"><dt><b>Description:</b></dt><dd>A dynamic property of the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> class that represents the Start of the LP or QP model; it will be generated after solving. It also can be given before solving to help CPLEX&reg; reach a solution. This is an optional structure that contains one start.</dd></dl>
<p>Use <code>cplex.findprop('Start').delete</code> to remove this property.</p>
<dl class="user"><dt><b>Fields:</b></dt><dd><table  class="usertable">
<tr>
<th>Field </th><th>Type </th><th>Description  </th></tr>
<tr>
<td>x </td><td>Double column vector </td><td>Vector containing the initial primal values of the column variables. The length of the vector must be equal to the number of columns in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object.  </td></tr>
<tr>
<td>Ax </td><td>Double column vector </td><td>Vector containing the initial primal values of constraints. The length of the vector must be no less than the number of rows in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object.   </td></tr>
<tr>
<td>dual </td><td>Double column vector </td><td>Vector containing the initial primal dual values for a range of the constraints in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. The length of the vector must be no less than the number of rows in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. This vector may be empty   </td></tr>
<tr>
<td>reducedcost </td><td>Double column vector </td><td>Vector containing the initial values of the reduced costs for the column variables. The length of the vector must be no less than the number of columns in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. This vector may be empty.   </td></tr>
<tr>
<td>basis </td><td>Struct </td><td>Structure with fields <code>colstat</code> and <code>rowstat</code>.  </td></tr>
<tr>
<td>basis.rowstat </td><td>Int32 column vector </td><td>Vector containing the basis status of the slack, surplus, or artificial variable associated with each row in the constraint matrix. The length of the vector is equal to the number of rows in the LP problem. For rows other than ranged rows, the vector element rowstat(i) can be set according to the following table. <table class="doxtable">
<tr>
<td>0 </td><td>Associated slack variable nonbasic at value 0  </td></tr>
<tr>
<td>1 </td><td>Associated slack artificial variable basic  </td></tr>
</table>
For ranged rows, the vector element rowstat(i) can be set according to the following table. <table class="doxtable">
<tr>
<td>0 </td><td>Associated slack variable nonbasic at its lower bound  </td></tr>
<tr>
<td>1 </td><td>Associated slack variable basic   </td></tr>
<tr>
<td>2 </td><td>Associated slack variable nonbasic at upper bound  </td></tr>
</table>
If this vector is empty, colstat must be empty.  </td></tr>
<tr>
<td>basis.colstat </td><td>Int32 column vector </td><td><p class="starttd">Vector containing the basis status of the columns in the constraint matrix. The length of the vector is equal to the number of columns in the <a class="el" href="classCplex.html" title="The Cplex class is the math programming solver.">Cplex</a> problem object. If this vector is empty, rowstat must be empty. </p>
<table  cellpadding="5">
<tr>
<td>0 </td><td>Variable at lower bound  </td></tr>
<tr>
<td>1 </td><td>Variable is basic  </td></tr>
<tr>
<td>2 </td><td>Variable at upper bound  </td></tr>
<tr>
<td>3 </td><td>Variable free and nonbasic  </td></tr>
</table>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b>Note:</b></dt><dd>Any of three different kinds of starting points can be provided: <ul>
<li>
a starting basis (colstat, rowstat), </li>
<li>
starting primal values (x,xindices) or  </li>
<li>
starting dual values </li>
</ul>
</dd></dl>
<p>For Dual Simplex and Primal Simplex any combination of these three types of information can be of use in providing a starting point.</p>
<p>If you provide a starting basis, then both colstat and rowstat must be specified.</p>
<p>It is permissible to provide dual values with or without reducedcosts, or reducedcosts with or without dual values vectors not being provided must be passed as null pointers.</p>
<p>Starting information is not applicable to the barrier optimizer or the mixed integer optimizer. </p>

</div>
</div>
</div>
<div class="copyright">&copy; Copyright IBM Corporation 2008, 2011. All Rights Reserved.</div>
</body>
</html>
